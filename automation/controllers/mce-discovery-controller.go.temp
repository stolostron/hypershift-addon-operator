package controllers

import (
	"context"
	"fmt"
	"time"

	"github.com/go-logr/logr"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

	addonv1alpha1 "open-cluster-management.io/api/addon/v1alpha1"
	clusterv1 "open-cluster-management.io/api/cluster/v1"
	policyv1 "open-cluster-management.io/api/policy/v1"
)

const (
	// MCEDiscoveryControllerName is the name of the controller
	MCEDiscoveryControllerName = "mce-discovery-controller"

	// MCEClusterLabel identifies MCE clusters
	MCEClusterLabel = "cluster.open-cluster-management.io/mce-cluster"

	// DiscoverySetupLabel indicates discovery setup is completed
	DiscoverySetupLabel = "hypershift.open-cluster-management.io/discovery-setup"

	// Default configuration
	DefaultAddonNamespace  = "open-cluster-management-agent-addon-discovery"
	DefaultACMNamespace    = "multicluster-engine"
	DefaultPolicyNamespace = "open-cluster-management-global-set"
)

// MCEDiscoveryController automates the setup of MCE hosted cluster discovery
type MCEDiscoveryController struct {
	client.Client
	Scheme *runtime.Scheme
	Log    logr.Logger

	// Configuration
	AddonNamespace  string
	ACMNamespace    string
	PolicyNamespace string
}

// +kubebuilder:rbac:groups=cluster.open-cluster-management.io,resources=managedclusters,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=addon.open-cluster-management.io,resources=managedclusteraddons,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=addon.open-cluster-management.io,resources=addondeploymentconfigs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=addon.open-cluster-management.io,resources=clustermanagementaddons,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=config.open-cluster-management.io,resources=klusterletconfigs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=policy.open-cluster-management.io,resources=policies,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cluster.open-cluster-management.io,resources=placements,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=policy.open-cluster-management.io,resources=placementbindings,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="",resources=configmaps,verbs=get;list;watch;create;update;patch;delete

// Reconcile handles the reconciliation of MCE clusters for discovery setup
func (r *MCEDiscoveryController) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := r.Log.WithValues("managedcluster", req.NamespacedName)

	// Get the ManagedCluster
	managedCluster := &clusterv1.ManagedCluster{}
	if err := r.Get(ctx, req.NamespacedName, managedCluster); err != nil {
		if apierrors.IsNotFound(err) {
			log.Info("ManagedCluster not found, may have been deleted")
			return ctrl.Result{}, nil
		}
		log.Error(err, "Failed to get ManagedCluster")
		return ctrl.Result{}, err
	}

	// Check if this is an MCE cluster
	if !r.isMCECluster(managedCluster) {
		log.V(1).Info("Not an MCE cluster, skipping")
		return ctrl.Result{}, nil
	}

	// Check if discovery setup is already completed
	if r.isDiscoverySetupCompleted(managedCluster) {
		log.V(1).Info("Discovery setup already completed for this cluster")
		return ctrl.Result{}, nil
	}

	log.Info("Setting up discovery for MCE cluster")

	// Ensure global configuration is set up
	if err := r.ensureGlobalConfiguration(ctx); err != nil {
		log.Error(err, "Failed to ensure global configuration")
		return ctrl.Result{RequeueAfter: time.Minute * 5}, err
	}

	// Setup hypershift addon for the MCE cluster
	if err := r.setupHypershiftAddon(ctx, managedCluster); err != nil {
		log.Error(err, "Failed to setup hypershift addon")
		return ctrl.Result{RequeueAfter: time.Minute * 2}, err
	}

	// Mark discovery setup as completed
	if err := r.markDiscoverySetupCompleted(ctx, managedCluster); err != nil {
		log.Error(err, "Failed to mark discovery setup as completed")
		return ctrl.Result{RequeueAfter: time.Minute}, err
	}

	log.Info("Discovery setup completed for MCE cluster")
	return ctrl.Result{}, nil
}

// isMCECluster determines if a managed cluster is an MCE cluster
func (r *MCEDiscoveryController) isMCECluster(mc *clusterv1.ManagedCluster) bool {
	// Check for MCE cluster label
	if value, exists := mc.Labels[MCEClusterLabel]; exists && value == "true" {
		return true
	}

	// Check for vendor label indicating MCE
	if vendor, exists := mc.Labels["vendor"]; exists && vendor == "OpenShift" {
		// Additional checks could be added here to identify MCE clusters
		// For now, we rely on explicit labeling
		return false
	}

	return false
}

// isDiscoverySetupCompleted checks if discovery setup is already completed
func (r *MCEDiscoveryController) isDiscoverySetupCompleted(mc *clusterv1.ManagedCluster) bool {
	value, exists := mc.Labels[DiscoverySetupLabel]
	return exists && value == "true"
}

// ensureGlobalConfiguration ensures the global ACM configuration is set up
func (r *MCEDiscoveryController) ensureGlobalConfiguration(ctx context.Context) error {
	// Ensure AddOnDeploymentConfig for addon namespace
	if err := r.ensureAddonDeploymentConfig(ctx); err != nil {
		return fmt.Errorf("failed to ensure addon deployment config: %w", err)
	}

	// Ensure KlusterletConfig for MCE import
	if err := r.ensureKlusterletConfig(ctx); err != nil {
		return fmt.Errorf("failed to ensure klusterlet config: %w", err)
	}

	// Ensure auto-import policy
	if err := r.ensureAutoImportPolicy(ctx); err != nil {
		return fmt.Errorf("failed to ensure auto-import policy: %w", err)
	}

	return nil
}

// ensureAddonDeploymentConfig creates the addon deployment config if it doesn't exist
func (r *MCEDiscoveryController) ensureAddonDeploymentConfig(ctx context.Context) error {
	config := &addonv1alpha1.AddOnDeploymentConfig{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "addon-ns-config",
			Namespace: r.ACMNamespace,
		},
	}

	_, err := controllerutil.CreateOrUpdate(ctx, r.Client, config, func() error {
		config.Spec.AgentInstallNamespace = r.AddonNamespace
		return nil
	})

	return err
}

// ensureKlusterletConfig creates the klusterlet config if it doesn't exist
func (r *MCEDiscoveryController) ensureKlusterletConfig(ctx context.Context) error {
	// Note: This would require importing the appropriate API types
	// For now, this is a placeholder showing the structure

	// klusterletConfig := &configv1alpha1.KlusterletConfig{
	// 	ObjectMeta: metav1.ObjectMeta{
	// 		Name: "mce-import-klusterlet-config",
	// 	},
	// }

	// _, err := controllerutil.CreateOrUpdate(ctx, r.Client, klusterletConfig, func() error {
	// 	klusterletConfig.Spec.InstallMode = configv1alpha1.InstallMode{
	// 		Type: "noOperator",
	// 		NoOperator: &configv1alpha1.NoOperator{
	// 			Postfix: "mce-import",
	// 		},
	// 	}
	// 	return nil
	// })

	// return err

	// For now, return nil as a placeholder
	return nil
}

// ensureAutoImportPolicy creates the auto-import policy if it doesn't exist
func (r *MCEDiscoveryController) ensureAutoImportPolicy(ctx context.Context) error {
	// Check if policy already exists
	policy := &policyv1.Policy{}
	err := r.Get(ctx, types.NamespacedName{
		Name:      "policy-mce-hcp-autoimport",
		Namespace: r.PolicyNamespace,
	}, policy)

	if err != nil && !apierrors.IsNotFound(err) {
		return err
	}

	if apierrors.IsNotFound(err) {
		// Create the policy
		policy = r.buildAutoImportPolicy()
		return r.Create(ctx, policy)
	}

	return nil
}

// buildAutoImportPolicy builds the auto-import policy
func (r *MCEDiscoveryController) buildAutoImportPolicy() *policyv1.Policy {
	// This is a simplified version. The actual implementation would include
	// the full policy template from the documentation

	policy := &policyv1.Policy{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "policy-mce-hcp-autoimport",
			Namespace: r.PolicyNamespace,
			Annotations: map[string]string{
				"policy.open-cluster-management.io/standards":   "NIST SP 800-53",
				"policy.open-cluster-management.io/categories":  "CM Configuration Management",
				"policy.open-cluster-management.io/controls":    "CM-2 Baseline Configuration",
				"policy.open-cluster-management.io/description": "Auto-import discovered MultiClusterEngineHCP clusters",
			},
		},
		Spec: policyv1.PolicySpec{
			Disabled: false,
			// PolicyTemplates would be added here with the full template
		},
	}

	return policy
}

// setupHypershiftAddon sets up the hypershift addon for the MCE cluster
func (r *MCEDiscoveryController) setupHypershiftAddon(ctx context.Context, mc *clusterv1.ManagedCluster) error {
	// Create ManagedClusterAddOn for hypershift-addon
	addon := &addonv1alpha1.ManagedClusterAddOn{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "hypershift-addon",
			Namespace: mc.Name,
		},
	}

	_, err := controllerutil.CreateOrUpdate(ctx, r.Client, addon, func() error {
		addon.Spec.InstallNamespace = r.AddonNamespace
		return nil
	})

	return err
}

// markDiscoverySetupCompleted marks the discovery setup as completed
func (r *MCEDiscoveryController) markDiscoverySetupCompleted(ctx context.Context, mc *clusterv1.ManagedCluster) error {
	if mc.Labels == nil {
		mc.Labels = make(map[string]string)
	}
	mc.Labels[DiscoverySetupLabel] = "true"

	return r.Update(ctx, mc)
}

// SetupWithManager sets up the controller with the Manager
func (r *MCEDiscoveryController) SetupWithManager(mgr ctrl.Manager) error {
	// Set default values if not configured
	if r.AddonNamespace == "" {
		r.AddonNamespace = DefaultAddonNamespace
	}
	if r.ACMNamespace == "" {
		r.ACMNamespace = DefaultACMNamespace
	}
	if r.PolicyNamespace == "" {
		r.PolicyNamespace = DefaultPolicyNamespace
	}

	return ctrl.NewControllerManagedBy(mgr).
		For(&clusterv1.ManagedCluster{}).
		Owns(&addonv1alpha1.ManagedClusterAddOn{}).
		Complete(r)
}

// NewMCEDiscoveryController creates a new MCE Discovery Controller
func NewMCEDiscoveryController(client client.Client, scheme *runtime.Scheme, log logr.Logger) *MCEDiscoveryController {
	return &MCEDiscoveryController{
		Client: client,
		Scheme: scheme,
		Log:    log.WithName(MCEDiscoveryControllerName),

		AddonNamespace:  DefaultAddonNamespace,
		ACMNamespace:    DefaultACMNamespace,
		PolicyNamespace: DefaultPolicyNamespace,
	}
}
